import React from 'react';
import {stopList, inverted_indexes, TagsNeeded} from '../variables/variables';
import {calculateRunningTime} from "./CalculateMemorySpaceAndTime";

export const parseXML = (insertFile) => {
    let begin = new Date();
    const parser = new DOMParser();
    const dom = parser.parseFromString(insertFile, "application/xml");

    let records = new Set();
    records = dom.getElementsByTagName("RECORD");

    // find needed tags
    let autoGeneratedId = 0;
    for (const record of records){
        let record_id = record.getElementsByTagName("RECORDNUM")[0] == undefined ? autoGeneratedId : record.getElementsByTagName("RECORDNUM")[0].childNodes[0].data;
        autoGeneratedId++; // increment autoGeneratedId to record the sequence of doc being read
        for (const tag of record.getElementsByTagName("*")){
            let tagName = tag.tagName;
            if(TagsNeeded.has(tagName)){ // if tag is in the NotNeeded set, tokenize it
                tokenizing(record_id, record.getElementsByTagName(tagName)[0].childNodes[0].data)
            }
        }
    }

    const sorted = [];
    for(const key in inverted_indexes) {
        sorted[sorted.length] = key;
    }
    sorted.sort();
    let end = new Date();
    calculateRunningTime(begin, end);
    return sorted
}

export const checkExtension = (file) => {
    const extension = file.target.files[0].name.match(/\.[0-9a-z]+$/i);
    if (extension!=".xml"){ //alert if inserted file is not an xml file
        alert("this is not an xml file");
    }
}

export const checkApostrophe = (word) => {
    return word.match(/\'/);
}

export const tokenizing = (record_id, paragraph) => {
    let words = paragraph.split(/[\[\]<>.,\/#!$%\^&\*;:{}=_()?@\s\"]/g); //split paragraphs by punctuation marks and space(s)
    for (let word of words){
        word = word.toLowerCase();
        word = word.replace(/[\-_~\d+]/g,"") // remove hyphens and digits
        if(word == null || word.length==0 || stopList.includes(word)){ // default check
            continue;
        }
        else if (checkApostrophe(word)){ // if a word has apostrophes, ignore for now
            continue;
        }
        else{
            indexing(record_id, word);
        }
    }
}

export const indexing = (record_id, word) => {
    let list = (word in inverted_indexes) ? inverted_indexes[word]:[]
    if (!list.includes(record_id)){
        list.push(record_id);
        inverted_indexes[word] = list;
    }
}

export default {
    parseXML, checkExtension, checkApostrophe
}